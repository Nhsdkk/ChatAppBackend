// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: interests_query.sql

package db_queries

import (
	"context"

	"chat_app_backend/internal/extensions"
)

const assignInterestsToUser = `-- name: AssignInterestsToUser :exec
INSERT INTO user_interests
(user_id, interest_id)
VALUES
($1, unnest($2::uuid[]))
`

type AssignInterestsToUserParams struct {
	UserID      extensions.UUID
	InterestIds []extensions.UUID
}

func (q *Queries) AssignInterestsToUser(ctx context.Context, arg AssignInterestsToUserParams) error {
	_, err := q.db.Exec(ctx, assignInterestsToUser, arg.UserID, arg.InterestIds)
	return err
}

const createInterest = `-- name: CreateInterest :one
INSERT INTO interests
(title, icon_file_name, description)
VALUES
($1, $2, $3)
RETURNING id, title, icon_file_name, created_at, updated_at, description
`

type CreateInterestParams struct {
	Title        string
	IconFileName string
	Description  string
}

func (q *Queries) CreateInterest(ctx context.Context, arg CreateInterestParams) (Interest, error) {
	row := q.db.QueryRow(ctx, createInterest, arg.Title, arg.IconFileName, arg.Description)
	var i Interest
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.IconFileName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
	)
	return i, err
}

const deleteInterest = `-- name: DeleteInterest :exec
DELETE FROM interests
WHERE interests.id = $1
`

func (q *Queries) DeleteInterest(ctx context.Context, id extensions.UUID) error {
	_, err := q.db.Exec(ctx, deleteInterest, id)
	return err
}

const getManyInterestsByFilters = `-- name: GetManyInterestsByFilters :many
SELECT id, title, icon_file_name, created_at, updated_at, description
FROM interests
WHERE
    ($1::uuid[] IS NULL OR interests.id = ANY($1::uuid[]))
  AND
    ($2::text IS NULL OR interests.title ILIKE $2::text || '%')
`

type GetManyInterestsByFiltersParams struct {
	Ids  []extensions.UUID
	Name *string
}

func (q *Queries) GetManyInterestsByFilters(ctx context.Context, arg GetManyInterestsByFiltersParams) ([]Interest, error) {
	rows, err := q.db.Query(ctx, getManyInterestsByFilters, arg.Ids, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Interest{}
	for rows.Next() {
		var i Interest
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.IconFileName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserInterests = `-- name: GetUserInterests :many
SELECT 
    interests.id,
    interests.title,
    interests.icon_file_name,
    interests.created_at,
    interests.updated_at,
    interests.description
FROM interests
JOIN user_interests on interests.id = user_interests.interest_id
WHERE user_interests.user_id = $1
`

func (q *Queries) GetUserInterests(ctx context.Context, id extensions.UUID) ([]Interest, error) {
	rows, err := q.db.Query(ctx, getUserInterests, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Interest{}
	for rows.Next() {
		var i Interest
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.IconFileName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserInterest = `-- name: RemoveUserInterest :exec
DELETE FROM user_interests
WHERE
    user_id = $1 AND
    interest_id = ANY ($2::uuid[])
`

type RemoveUserInterestParams struct {
	UserID      extensions.UUID
	InterestIds []extensions.UUID
}

func (q *Queries) RemoveUserInterest(ctx context.Context, arg RemoveUserInterestParams) error {
	_, err := q.db.Exec(ctx, removeUserInterest, arg.UserID, arg.InterestIds)
	return err
}

const updateInterestDescription = `-- name: UpdateInterestDescription :one
UPDATE interests
SET
    description = $1
WHERE
    id = $2
RETURNING id, title, icon_file_name, created_at, updated_at, description
`

type UpdateInterestDescriptionParams struct {
	Description string
	ID          extensions.UUID
}

func (q *Queries) UpdateInterestDescription(ctx context.Context, arg UpdateInterestDescriptionParams) (Interest, error) {
	row := q.db.QueryRow(ctx, updateInterestDescription, arg.Description, arg.ID)
	var i Interest
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.IconFileName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
	)
	return i, err
}
