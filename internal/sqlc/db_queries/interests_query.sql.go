// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: interests_query.sql

package db_queries

import (
	"context"

	"github.com/google/uuid"
)

const assignInterestsToUser = `-- name: AssignInterestsToUser :exec
INSERT INTO user_interests
(user_id, interest_id)
VALUES
($1, unnest($2::uuid[]))
`

type AssignInterestsToUserParams struct {
	UserID      uuid.UUID
	InterestIds []uuid.UUID
}

func (q *Queries) AssignInterestsToUser(ctx context.Context, arg AssignInterestsToUserParams) error {
	_, err := q.db.Exec(ctx, assignInterestsToUser, arg.UserID, arg.InterestIds)
	return err
}

const createInterest = `-- name: CreateInterest :one
INSERT INTO interests
(title, icon_file_name)
VALUES
($1, $2)
RETURNING id, title, icon_file_name, created_at, updated_at
`

type CreateInterestParams struct {
	Title        string
	IconFileName string
}

func (q *Queries) CreateInterest(ctx context.Context, arg CreateInterestParams) (Interest, error) {
	row := q.db.QueryRow(ctx, createInterest, arg.Title, arg.IconFileName)
	var i Interest
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.IconFileName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInterest = `-- name: DeleteInterest :exec
DELETE FROM interests
WHERE interests.id = $1
`

func (q *Queries) DeleteInterest(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInterest, id)
	return err
}

const getManyInterestsById = `-- name: GetManyInterestsById :many
SELECT id, title, icon_file_name, created_at, updated_at FROM interests
WHERE interests.id = ANY($1::uuid[])
`

func (q *Queries) GetManyInterestsById(ctx context.Context, ids []uuid.UUID) ([]Interest, error) {
	rows, err := q.db.Query(ctx, getManyInterestsById, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Interest
	for rows.Next() {
		var i Interest
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.IconFileName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserInterests = `-- name: GetUserInterests :many
SELECT 
    interests.id,
    interests.title,
    interests.icon_file_name,
    interests.created_at,
    interests.updated_at
FROM interests
JOIN user_interests on interests.id = user_interests.interest_id
WHERE user_interests.user_id = $1
`

func (q *Queries) GetUserInterests(ctx context.Context, id uuid.UUID) ([]Interest, error) {
	rows, err := q.db.Query(ctx, getUserInterests, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Interest
	for rows.Next() {
		var i Interest
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.IconFileName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserInterest = `-- name: RemoveUserInterest :exec
DELETE FROM user_interests
WHERE
    user_id = $1 AND
    interest_id = ANY ($2::uuid[])
`

type RemoveUserInterestParams struct {
	UserID      uuid.UUID
	InterestIds []uuid.UUID
}

func (q *Queries) RemoveUserInterest(ctx context.Context, arg RemoveUserInterestParams) error {
	_, err := q.db.Exec(ctx, removeUserInterest, arg.UserID, arg.InterestIds)
	return err
}

const updateInterestIcon = `-- name: UpdateInterestIcon :one
UPDATE interests
SET
    icon_file_name = $1
WHERE
    interests.id = $2
RETURNING id, title, icon_file_name, created_at, updated_at
`

type UpdateInterestIconParams struct {
	IconFileName string
	ID           uuid.UUID
}

func (q *Queries) UpdateInterestIcon(ctx context.Context, arg UpdateInterestIconParams) (Interest, error) {
	row := q.db.QueryRow(ctx, updateInterestIcon, arg.IconFileName, arg.ID)
	var i Interest
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.IconFileName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
